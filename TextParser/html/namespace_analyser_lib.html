<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="de">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CppPruefung: AnalyserLib-Namensbereichsreferenz</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">CppPruefung
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Erzeugt von Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Suchen',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('namespace_analyser_lib.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Lade ...</div>
<div class="SRStatus" id="Searching">Suche ...</div>
<div class="SRStatus" id="NoMatches">Keine Treffer</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">AnalyserLib-Namensbereichsreferenz</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Klassen</h2></td></tr>
<tr class="memitem:SearchResult" id="r_SearchResult"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_analyser_lib_1_1_search_result.html">SearchResult</a></td></tr>
<tr class="memitem:PairHash" id="r_PairHash"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_analyser_lib_1_1_pair_hash.html">PairHash</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typdefinitionen</h2></td></tr>
<tr class="memitem:aae85ee1355305b0bfd3aeb0173e0ee4a" id="r_aae85ee1355305b0bfd3aeb0173e0ee4a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae85ee1355305b0bfd3aeb0173e0ee4a">wordDistribution</a> = std::unordered_map&lt;std::string, int&gt;</td></tr>
<tr class="memdesc:aae85ee1355305b0bfd3aeb0173e0ee4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">defines für bessere lesbarkeit  <br /></td></tr>
<tr class="memitem:a53dbf6b37e0fb454852a6a3f48843b24" id="r_a53dbf6b37e0fb454852a6a3f48843b24"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> = const std::vector&lt;std::string&gt;</td></tr>
<tr class="memdesc:a53dbf6b37e0fb454852a6a3f48843b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">ein const vector of string, bessere lesbarkeit  <br /></td></tr>
<tr class="memitem:a99c7106caf7cb4f7b2d9d211a337043f" id="r_a99c7106caf7cb4f7b2d9d211a337043f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99c7106caf7cb4f7b2d9d211a337043f">wordLengthDistibution</a> = std::map&lt;int, int&gt;</td></tr>
<tr class="memitem:af17700dac156a0cb20b53b7354833bfc" id="r_af17700dac156a0cb20b53b7354833bfc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af17700dac156a0cb20b53b7354833bfc">stringList</a> = std::vector&lt;std::string&gt;</td></tr>
<tr class="memdesc:af17700dac156a0cb20b53b7354833bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">ein vector of string, bessere lesbarkeit  <br /></td></tr>
<tr class="memitem:ae305cdd2e542f797a170dcf8d80eb765" id="r_ae305cdd2e542f797a170dcf8d80eb765"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae305cdd2e542f797a170dcf8d80eb765">searchList</a> = std::vector&lt;<a class="el" href="struct_analyser_lib_1_1_search_result.html">SearchResult</a>&gt;</td></tr>
<tr class="memdesc:ae305cdd2e542f797a170dcf8d80eb765"><td class="mdescLeft">&#160;</td><td class="mdescRight">ein Vector of <a class="el" href="struct_analyser_lib_1_1_search_result.html">SearchResult</a>  <br /></td></tr>
<tr class="memitem:a3aa80ba17672b28dab9d21a8e4b80174" id="r_a3aa80ba17672b28dab9d21a8e4b80174"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aa80ba17672b28dab9d21a8e4b80174">strPair</a> = std::pair&lt;std::string, std::string&gt;</td></tr>
<tr class="memdesc:a3aa80ba17672b28dab9d21a8e4b80174"><td class="mdescLeft">&#160;</td><td class="mdescRight">ein string tuple um 2 Worte zu verknüpfen  <br /></td></tr>
<tr class="memitem:a9070030da5f341889464c96bb7eeef63" id="r_a9070030da5f341889464c96bb7eeef63"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9070030da5f341889464c96bb7eeef63">wordPairs</a> = std::unordered_map&lt;<a class="el" href="#a3aa80ba17672b28dab9d21a8e4b80174">strPair</a>, int, <a class="el" href="struct_analyser_lib_1_1_pair_hash.html">PairHash</a>&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
AufzÃ¤hlungen</h2></td></tr>
<tr class="memitem:ad2ef6024965a174775da9bffc1c64b95" id="r_ad2ef6024965a174775da9bffc1c64b95"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2ef6024965a174775da9bffc1c64b95">cleanupType</a> { <br />
&#160;&#160;<a class="el" href="#ad2ef6024965a174775da9bffc1c64b95a6cbfa65fb0625f4b8ef181fae3e9f500">None</a> = 0
, <a class="el" href="#ad2ef6024965a174775da9bffc1c64b95a0d85be9676eff76c2752319c04414977">plain</a> = 1
, <a class="el" href="#ad2ef6024965a174775da9bffc1c64b95ada272a9faf21999d6d4275bb0fe48a2f">removeAllSigns</a> = 2
, <a class="el" href="#ad2ef6024965a174775da9bffc1c64b95aa1202c921a77a7868ea28dcfd6ae24c2">HTML</a> = 4
, <br />
&#160;&#160;<a class="el" href="#ad2ef6024965a174775da9bffc1c64b95a6e7b05077b5526cce938c6c0569a3891">Markdown</a> = 8
<br />
 }</td></tr>
<tr class="memitem:ad2d4d9ba367c8ed182a4e3c77b287ed1" id="r_ad2d4d9ba367c8ed182a4e3c77b287ed1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1">ReadabilityScore</a> { <br />
&#160;&#160;<a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1af2fe94ae80f172c39e2703aab36a76be">VeryEasy</a>
, <a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1adadd3829c458ac4595558b356a75839e">Easy</a>
, <a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1a208527d09cbd547ecfc485313d174042">MediumEasy</a>
, <a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1af0115966541df18fca3a4f58f2c26087">Medium</a>
, <br />
&#160;&#160;<a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1a18c1fc5b4a39d7339d3fc1deaf9660bf">MediumHard</a>
, <a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1a901ddd973112d82e67d71a96ca288e24">Hard</a>
, <a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1a42a7840b2e614dfc0fc76ae01384d54f">VeryHard</a>
<br />
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Funktionen</h2></td></tr>
<tr class="memitem:a1d9ec8b1743fde607707329552284a71" id="r_a1d9ec8b1743fde607707329552284a71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d9ec8b1743fde607707329552284a71">toLowerCase</a> (string &amp;word)</td></tr>
<tr class="memitem:ae76dba2a04e10748d1d076c77ea0b458" id="r_ae76dba2a04e10748d1d076c77ea0b458"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae76dba2a04e10748d1d076c77ea0b458">getTextPart</a> (const std::string &amp;text, const int &amp;start, int &amp;length, bool &amp;useLowerCase)</td></tr>
<tr class="memitem:a7a0a1e324db8026edd0029b62eaaa58d" id="r_a7a0a1e324db8026edd0029b62eaaa58d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af17700dac156a0cb20b53b7354833bfc">stringList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a0a1e324db8026edd0029b62eaaa58d">splitTextIntoStringList</a> (const std::string &amp;text, bool useLowerCase, const string &amp;endSignes)</td></tr>
<tr class="memitem:ac9f8b198f445ead40bcaa5897e72c8ae" id="r_ac9f8b198f445ead40bcaa5897e72c8ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af17700dac156a0cb20b53b7354833bfc">stringList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9f8b198f445ead40bcaa5897e72c8ae">splitTextIntoStringListAsync</a> (const std::string &amp;text, bool useLowerCase, const std::string &amp;endingPattern)</td></tr>
<tr class="memitem:a39b9c2eaa61dee96f64d8f3de44e5447" id="r_a39b9c2eaa61dee96f64d8f3de44e5447"><td class="memItemLeft" align="right" valign="top">Stats&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39b9c2eaa61dee96f64d8f3de44e5447">getStats</a> (size_t hashValue)</td></tr>
<tr class="memitem:ae040414914bc25ce45108ad77d20ee71" id="r_ae040414914bc25ce45108ad77d20ee71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae040414914bc25ce45108ad77d20ee71">saveStats</a> (size_t hashValue, Stats s)</td></tr>
<tr class="memitem:a472d0fc6a8d23fb4d37c7f0b6252dffa" id="r_a472d0fc6a8d23fb4d37c7f0b6252dffa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a472d0fc6a8d23fb4d37c7f0b6252dffa">clearCache</a> ()</td></tr>
<tr class="memitem:a6907b5b78933ebacb49b4ccd92aec2de" id="r_a6907b5b78933ebacb49b4ccd92aec2de"><td class="memItemLeft" align="right" valign="top">Stats&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6907b5b78933ebacb49b4ccd92aec2de">createStatistics</a> (const std::string &amp;text, const string &amp;wordEndSignes, const string &amp;sentenceEndSignes)</td></tr>
<tr class="memitem:a8c372d8a62e6e383219dfb5b6a48cdf8" id="r_a8c372d8a62e6e383219dfb5b6a48cdf8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c372d8a62e6e383219dfb5b6a48cdf8">countTotalWords</a> (const std::string &amp;text)</td></tr>
<tr class="memitem:af0778e0ffdc60688b454a332b0038841" id="r_af0778e0ffdc60688b454a332b0038841"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0778e0ffdc60688b454a332b0038841">countTotalWordsAsync</a> (const std::string &amp;text)</td></tr>
<tr class="memitem:afeb610691fb21077c29d4f7e13f884e6" id="r_afeb610691fb21077c29d4f7e13f884e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aae85ee1355305b0bfd3aeb0173e0ee4a">wordDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afeb610691fb21077c29d4f7e13f884e6">createWordDistribution</a> (const std::string &amp;text, bool caseSensitive)</td></tr>
<tr class="memitem:a7f4351ba30ed6a99ee5bd45be7c67014" id="r_a7f4351ba30ed6a99ee5bd45be7c67014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aae85ee1355305b0bfd3aeb0173e0ee4a">wordDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f4351ba30ed6a99ee5bd45be7c67014">createWordDistribution</a> (const std::string &amp;text, <a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> &amp;stopWords, bool caseSensitive)</td></tr>
<tr class="memitem:a09c88e7303ce7ff98a88cfd781703a7a" id="r_a09c88e7303ce7ff98a88cfd781703a7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aae85ee1355305b0bfd3aeb0173e0ee4a">wordDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09c88e7303ce7ff98a88cfd781703a7a">createWordDistribution</a> (<a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> &amp;wordList, <a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> &amp;stopWords)</td></tr>
<tr class="memitem:a2ce7699f603e935dd12574232be6b995" id="r_a2ce7699f603e935dd12574232be6b995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aae85ee1355305b0bfd3aeb0173e0ee4a">wordDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ce7699f603e935dd12574232be6b995">createWordDistributionAsyncHelper</a> (<a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> &amp;wordList, <a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> &amp;stopWords)</td></tr>
<tr class="memitem:aefa2386a1b2f2933c2953258718a7927" id="r_aefa2386a1b2f2933c2953258718a7927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#aae85ee1355305b0bfd3aeb0173e0ee4a">wordDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefa2386a1b2f2933c2953258718a7927">createWordDistributionAsync</a> (<a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> &amp;wordList, <a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> &amp;stopWords)</td></tr>
<tr class="memitem:a44ad3c980bf0a22b7391ac934a9c738e" id="r_a44ad3c980bf0a22b7391ac934a9c738e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44ad3c980bf0a22b7391ac934a9c738e">cleanUpHtml</a> (string &amp;text)</td></tr>
<tr class="memitem:a2fd70e49893f5c26b5e21b68d1ec467b" id="r_a2fd70e49893f5c26b5e21b68d1ec467b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fd70e49893f5c26b5e21b68d1ec467b">cleanUpSigns</a> (std::string &amp;text, const string &amp;removeSigns)</td></tr>
<tr class="memitem:abb0af903e5e613c692ce2c15c5096a78" id="r_abb0af903e5e613c692ce2c15c5096a78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb0af903e5e613c692ce2c15c5096a78">cleanUpMarkdown</a> (string &amp;text)</td></tr>
<tr class="memitem:ac7841696ca00d9b391061bcb9cc14128" id="r_ac7841696ca00d9b391061bcb9cc14128"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7841696ca00d9b391061bcb9cc14128">cleanUpSpaces</a> (string &amp;text)</td></tr>
<tr class="memitem:a7a83e1604276a27df0a54d9d148547cc" id="r_a7a83e1604276a27df0a54d9d148547cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a83e1604276a27df0a54d9d148547cc">cleanUpText</a> (std::string &amp;text, <a class="el" href="#ad2ef6024965a174775da9bffc1c64b95">cleanupType</a> type)</td></tr>
<tr class="memitem:a7223601e7197362e3be25e1863de1de0" id="r_a7223601e7197362e3be25e1863de1de0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7223601e7197362e3be25e1863de1de0">readFile</a> (const std::string &amp;path, <a class="el" href="#ad2ef6024965a174775da9bffc1c64b95">cleanupType</a> type)</td></tr>
<tr class="memitem:a46e4e766540dd4de728753f1e64172ff" id="r_a46e4e766540dd4de728753f1e64172ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ae305cdd2e542f797a170dcf8d80eb765">searchList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46e4e766540dd4de728753f1e64172ff">findPatterns</a> (const std::string &amp;text, const std::regex &amp;pattern)</td></tr>
<tr class="memitem:a1dad10a08b0dbbf680e170b0fbf7b09c" id="r_a1dad10a08b0dbbf680e170b0fbf7b09c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1dad10a08b0dbbf680e170b0fbf7b09c">calculateWordLength</a> (const std::string &amp;text)</td></tr>
<tr class="memitem:ac7bb8302ed346f4de5eaa83ffc1c132e" id="r_ac7bb8302ed346f4de5eaa83ffc1c132e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac7bb8302ed346f4de5eaa83ffc1c132e">calculateSentenceLengthByWords</a> (const std::string &amp;text)</td></tr>
<tr class="memitem:aa4f0707aa5b80b8ccbfbe5238e8a19ed" id="r_aa4f0707aa5b80b8ccbfbe5238e8a19ed"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4f0707aa5b80b8ccbfbe5238e8a19ed">calculateSentenceLengthByLetters</a> (const std::string &amp;text)</td></tr>
<tr class="memitem:a5753c343f77ca23e994c3bcb442342b8" id="r_a5753c343f77ca23e994c3bcb442342b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a99c7106caf7cb4f7b2d9d211a337043f">wordLengthDistibution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5753c343f77ca23e994c3bcb442342b8">calculateWordLengthDistibution</a> (const std::string &amp;text, const std::string &amp;wordEndSignes)</td></tr>
<tr class="memitem:af19bb8b6141c9b6d92184aa19262a86b" id="r_af19bb8b6141c9b6d92184aa19262a86b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a99c7106caf7cb4f7b2d9d211a337043f">wordLengthDistibution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af19bb8b6141c9b6d92184aa19262a86b">calculateWordLengthDistibutionAsync</a> (const std::string &amp;text, const std::string &amp;wordEndSignes)</td></tr>
<tr class="memitem:a2498f93d0680f951204fc0f5519773d8" id="r_a2498f93d0680f951204fc0f5519773d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9070030da5f341889464c96bb7eeef63">wordPairs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2498f93d0680f951204fc0f5519773d8">findConnectedWords</a> (const std::string &amp;text, int minOccurrences, int range)</td></tr>
<tr class="memitem:acdd26e8ecfd98b0f1053fa3dacb9de68" id="r_acdd26e8ecfd98b0f1053fa3dacb9de68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a9070030da5f341889464c96bb7eeef63">wordPairs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acdd26e8ecfd98b0f1053fa3dacb9de68">findConnectedWordsAsync</a> (const std::string &amp;text, int minOccurrences, int range)</td></tr>
<tr class="memitem:afc6a66c3cd79b7ccb5993847aa75e40d" id="r_afc6a66c3cd79b7ccb5993847aa75e40d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1">ReadabilityScore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc6a66c3cd79b7ccb5993847aa75e40d">calculateGermanScore</a> (const std::string &amp;text)</td></tr>
<tr class="memitem:a979a39f6c26519d14a3978c5ad5a636a" id="r_a979a39f6c26519d14a3978c5ad5a636a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#af17700dac156a0cb20b53b7354833bfc">stringList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a979a39f6c26519d14a3978c5ad5a636a">splitTextIntoStringList</a> (const std::string &amp;text, bool useLowerCase=false, const std::string &amp;endingPattern=<a class="el" href="_text_analyser_8h.html#a3f852f86dc1aa3664c66f5b15abd857e">defaultWordEnd</a>)</td></tr>
<tr class="memitem:a40bce1b6d9206ac8ec1b994807cc3fe9" id="r_a40bce1b6d9206ac8ec1b994807cc3fe9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40bce1b6d9206ac8ec1b994807cc3fe9">scoreToString</a> (<a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1">ReadabilityScore</a> s)</td></tr>
</table>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Dokumentation der benutzerdefinierten Typen</h2>
<a id="a53dbf6b37e0fb454852a6a3f48843b24" name="a53dbf6b37e0fb454852a6a3f48843b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53dbf6b37e0fb454852a6a3f48843b24">&#9670;&#160;</a></span>constStringList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const std::vector&lt; std::string &gt; <a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">AnalyserLib::constStringList</a> = const std::vector&lt;std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ein const vector of string, bessere lesbarkeit </p>

</div>
</div>
<a id="ae305cdd2e542f797a170dcf8d80eb765" name="ae305cdd2e542f797a170dcf8d80eb765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae305cdd2e542f797a170dcf8d80eb765">&#9670;&#160;</a></span>searchList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#ae305cdd2e542f797a170dcf8d80eb765">AnalyserLib::searchList</a> = std::vector&lt;<a class="el" href="struct_analyser_lib_1_1_search_result.html">SearchResult</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ein Vector of <a class="el" href="struct_analyser_lib_1_1_search_result.html">SearchResult</a> </p>

</div>
</div>
<a id="af17700dac156a0cb20b53b7354833bfc" name="af17700dac156a0cb20b53b7354833bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17700dac156a0cb20b53b7354833bfc">&#9670;&#160;</a></span>stringList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#af17700dac156a0cb20b53b7354833bfc">AnalyserLib::stringList</a> = std::vector&lt;std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ein vector of string, bessere lesbarkeit </p>

</div>
</div>
<a id="a3aa80ba17672b28dab9d21a8e4b80174" name="a3aa80ba17672b28dab9d21a8e4b80174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa80ba17672b28dab9d21a8e4b80174">&#9670;&#160;</a></span>strPair</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a3aa80ba17672b28dab9d21a8e4b80174">AnalyserLib::strPair</a> = std::pair&lt;std::string, std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>ein string tuple um 2 Worte zu verknüpfen </p>

</div>
</div>
<a id="aae85ee1355305b0bfd3aeb0173e0ee4a" name="aae85ee1355305b0bfd3aeb0173e0ee4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae85ee1355305b0bfd3aeb0173e0ee4a">&#9670;&#160;</a></span>wordDistribution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aae85ee1355305b0bfd3aeb0173e0ee4a">AnalyserLib::wordDistribution</a> = std::unordered_map&lt;std::string, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>defines für bessere lesbarkeit </p>

</div>
</div>
<a id="a99c7106caf7cb4f7b2d9d211a337043f" name="a99c7106caf7cb4f7b2d9d211a337043f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c7106caf7cb4f7b2d9d211a337043f">&#9670;&#160;</a></span>wordLengthDistibution</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a99c7106caf7cb4f7b2d9d211a337043f">AnalyserLib::wordLengthDistibution</a> = std::map&lt;int, int&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9070030da5f341889464c96bb7eeef63" name="a9070030da5f341889464c96bb7eeef63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9070030da5f341889464c96bb7eeef63">&#9670;&#160;</a></span>wordPairs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a9070030da5f341889464c96bb7eeef63">AnalyserLib::wordPairs</a> = std::unordered_map&lt;<a class="el" href="#a3aa80ba17672b28dab9d21a8e4b80174">strPair</a>, int, <a class="el" href="struct_analyser_lib_1_1_pair_hash.html">PairHash</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Dokumentation der AufzÃ¤hlungstypen</h2>
<a id="ad2ef6024965a174775da9bffc1c64b95" name="ad2ef6024965a174775da9bffc1c64b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ef6024965a174775da9bffc1c64b95">&#9670;&#160;</a></span>cleanupType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ad2ef6024965a174775da9bffc1c64b95">AnalyserLib::cleanupType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum zum einstellen mit welcher methode der Text aufgeräumt werden soll </p>
<table class="fieldtable">
<tr><th colspan="2">AufzÃ¤hlungswerte</th></tr><tr><td class="fieldname"><a id="ad2ef6024965a174775da9bffc1c64b95a6cbfa65fb0625f4b8ef181fae3e9f500" name="ad2ef6024965a174775da9bffc1c64b95a6cbfa65fb0625f4b8ef181fae3e9f500"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2ef6024965a174775da9bffc1c64b95a0d85be9676eff76c2752319c04414977" name="ad2ef6024965a174775da9bffc1c64b95a0d85be9676eff76c2752319c04414977"></a>plain&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2ef6024965a174775da9bffc1c64b95ada272a9faf21999d6d4275bb0fe48a2f" name="ad2ef6024965a174775da9bffc1c64b95ada272a9faf21999d6d4275bb0fe48a2f"></a>removeAllSigns&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2ef6024965a174775da9bffc1c64b95aa1202c921a77a7868ea28dcfd6ae24c2" name="ad2ef6024965a174775da9bffc1c64b95aa1202c921a77a7868ea28dcfd6ae24c2"></a>HTML&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2ef6024965a174775da9bffc1c64b95a6e7b05077b5526cce938c6c0569a3891" name="ad2ef6024965a174775da9bffc1c64b95a6e7b05077b5526cce938c6c0569a3891"></a>Markdown&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad2d4d9ba367c8ed182a4e3c77b287ed1" name="ad2d4d9ba367c8ed182a4e3c77b287ed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d4d9ba367c8ed182a4e3c77b287ed1">&#9670;&#160;</a></span>ReadabilityScore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1">AnalyserLib::ReadabilityScore</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ein enum für die bessere Einteilung des Lesbarkeitswertes </p>
<table class="fieldtable">
<tr><th colspan="2">AufzÃ¤hlungswerte</th></tr><tr><td class="fieldname"><a id="ad2d4d9ba367c8ed182a4e3c77b287ed1af2fe94ae80f172c39e2703aab36a76be" name="ad2d4d9ba367c8ed182a4e3c77b287ed1af2fe94ae80f172c39e2703aab36a76be"></a>VeryEasy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2d4d9ba367c8ed182a4e3c77b287ed1adadd3829c458ac4595558b356a75839e" name="ad2d4d9ba367c8ed182a4e3c77b287ed1adadd3829c458ac4595558b356a75839e"></a>Easy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2d4d9ba367c8ed182a4e3c77b287ed1a208527d09cbd547ecfc485313d174042" name="ad2d4d9ba367c8ed182a4e3c77b287ed1a208527d09cbd547ecfc485313d174042"></a>MediumEasy&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2d4d9ba367c8ed182a4e3c77b287ed1af0115966541df18fca3a4f58f2c26087" name="ad2d4d9ba367c8ed182a4e3c77b287ed1af0115966541df18fca3a4f58f2c26087"></a>Medium&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2d4d9ba367c8ed182a4e3c77b287ed1a18c1fc5b4a39d7339d3fc1deaf9660bf" name="ad2d4d9ba367c8ed182a4e3c77b287ed1a18c1fc5b4a39d7339d3fc1deaf9660bf"></a>MediumHard&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2d4d9ba367c8ed182a4e3c77b287ed1a901ddd973112d82e67d71a96ca288e24" name="ad2d4d9ba367c8ed182a4e3c77b287ed1a901ddd973112d82e67d71a96ca288e24"></a>Hard&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2d4d9ba367c8ed182a4e3c77b287ed1a42a7840b2e614dfc0fc76ae01384d54f" name="ad2d4d9ba367c8ed182a4e3c77b287ed1a42a7840b2e614dfc0fc76ae01384d54f"></a>VeryHard&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Dokumentation der Funktionen</h2>
<a id="afc6a66c3cd79b7ccb5993847aa75e40d" name="afc6a66c3cd79b7ccb5993847aa75e40d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6a66c3cd79b7ccb5993847aa75e40d">&#9670;&#160;</a></span>calculateGermanScore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1">ReadabilityScore</a> AnalyserLib::calculateGermanScore </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Berechnet den Lesbarkeitswert eines Textes anhand des "Flesch - Reading - Ease - Score". Die Berechnung bezieht sich auf deutsche wörter und Texte.</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Der Text zum berechnen des Scores </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>Gibt den Score als <a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1">ReadabilityScore</a> Enum zurück. </dd></dl>

</div>
</div>
<a id="aa4f0707aa5b80b8ccbfbe5238e8a19ed" name="aa4f0707aa5b80b8ccbfbe5238e8a19ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f0707aa5b80b8ccbfbe5238e8a19ed">&#9670;&#160;</a></span>calculateSentenceLengthByLetters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AnalyserLib::calculateSentenceLengthByLetters </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Berechnet die durchschnittliche Satzlänge anhand von Zeichen</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Der Text zum berechnen </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>Gibt die durchschnittliche Zeichenanzahl pro Satz aus </dd></dl>

</div>
</div>
<a id="ac7bb8302ed346f4de5eaa83ffc1c132e" name="ac7bb8302ed346f4de5eaa83ffc1c132e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7bb8302ed346f4de5eaa83ffc1c132e">&#9670;&#160;</a></span>calculateSentenceLengthByWords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AnalyserLib::calculateSentenceLengthByWords </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Berechnet die durchschnittliche Satzlänge anhand von Wörtern</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Der Text zum berechnen </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>Gibt die durchschnittliche Wortanzahl pro Satz aus </dd></dl>

</div>
</div>
<a id="a1dad10a08b0dbbf680e170b0fbf7b09c" name="a1dad10a08b0dbbf680e170b0fbf7b09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dad10a08b0dbbf680e170b0fbf7b09c">&#9670;&#160;</a></span>calculateWordLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double AnalyserLib::calculateWordLength </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Berechnet die durchschnittliche Wortlänge</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Der Text zum berechnen </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>Gibt die durchschnittliche Wortlänge aus </dd></dl>

</div>
</div>
<a id="a5753c343f77ca23e994c3bcb442342b8" name="a5753c343f77ca23e994c3bcb442342b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5753c343f77ca23e994c3bcb442342b8">&#9670;&#160;</a></span>calculateWordLengthDistibution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a99c7106caf7cb4f7b2d9d211a337043f">wordLengthDistibution</a> AnalyserLib::calculateWordLengthDistibution </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>endingPattern</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="_text_analyser_8h.html#a3f852f86dc1aa3664c66f5b15abd857e">defaultWordEnd</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Berechnet die durchschnittliche Wortlängen verteilung. Also wie viele Worte gibt es von einer bestimmten länge</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Der Text zum berechnen endingPattern (defult = defaultWordEnd " .,-!?\n"): Damit wird definiert wann ein Wort zu ende ist und ein neues Wort beginnt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>Gibt eine map of int int zurück. Key ist die Anzahl der Buchstaben im Wort und der Value ist die Anzahl der Worte mit der selben Buchstaben zahl. </dd></dl>

</div>
</div>
<a id="af19bb8b6141c9b6d92184aa19262a86b" name="af19bb8b6141c9b6d92184aa19262a86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19bb8b6141c9b6d92184aa19262a86b">&#9670;&#160;</a></span>calculateWordLengthDistibutionAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a99c7106caf7cb4f7b2d9d211a337043f">wordLengthDistibution</a> AnalyserLib::calculateWordLengthDistibutionAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>endingPattern</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="_text_analyser_8h.html#a3f852f86dc1aa3664c66f5b15abd857e">defaultWordEnd</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Async version </p>

</div>
</div>
<a id="a44ad3c980bf0a22b7391ac934a9c738e" name="a44ad3c980bf0a22b7391ac934a9c738e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ad3c980bf0a22b7391ac934a9c738e">&#9670;&#160;</a></span>cleanUpHtml()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AnalyserLib::cleanUpHtml </td>
          <td>(</td>
          <td class="paramtype">string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[intern] Entfernt nur basis HTML tags und ist nicht für Komplexe HTML Dateien gedacht. An dieser Stelle ist es zu empfehlen einen Externen Parser einzufügen </p>

</div>
</div>
<a id="abb0af903e5e613c692ce2c15c5096a78" name="abb0af903e5e613c692ce2c15c5096a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0af903e5e613c692ce2c15c5096a78">&#9670;&#160;</a></span>cleanUpMarkdown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AnalyserLib::cleanUpMarkdown </td>
          <td>(</td>
          <td class="paramtype">string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[intern] Entfernt nur ein Teil vom Markdown tags und man muss definitv hier einen Parser einbauen der alles handlen kann. </p>

</div>
</div>
<a id="a2fd70e49893f5c26b5e21b68d1ec467b" name="a2fd70e49893f5c26b5e21b68d1ec467b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd70e49893f5c26b5e21b68d1ec467b">&#9670;&#160;</a></span>cleanUpSigns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AnalyserLib::cleanUpSigns </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>removeSigns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[intern] ersetzt aus eine Liste von Zeichen jedes Zeichen durch ein Leerzeichen </p>

</div>
</div>
<a id="ac7841696ca00d9b391061bcb9cc14128" name="ac7841696ca00d9b391061bcb9cc14128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7841696ca00d9b391061bcb9cc14128">&#9670;&#160;</a></span>cleanUpSpaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AnalyserLib::cleanUpSpaces </td>
          <td>(</td>
          <td class="paramtype">string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[intern] Entfernt überflüssige leerzeichen </p>

</div>
</div>
<a id="a7a83e1604276a27df0a54d9d148547cc" name="a7a83e1604276a27df0a54d9d148547cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a83e1604276a27df0a54d9d148547cc">&#9670;&#160;</a></span>cleanUpText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AnalyserLib::cleanUpText </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>origin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad2ef6024965a174775da9bffc1c64b95">cleanupType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ad2ef6024965a174775da9bffc1c64b95a0d85be9676eff76c2752319c04414977">cleanupType::plain</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Entfernt unerwünschte zeichen aus dem Text. Zeilenumbrüche und überflüssige Leerzeichen werden immer entfernt</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>Der Text der aufgeräumt werden soll. Origin wird in dieser Funktion direkt angepasst und ist gleichzeitig der return Wert. type (default=plain): Definiert die Methode mit der der Text aufgeräumt werden soll </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>void </dd></dl>

</div>
</div>
<a id="a472d0fc6a8d23fb4d37c7f0b6252dffa" name="a472d0fc6a8d23fb4d37c7f0b6252dffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472d0fc6a8d23fb4d37c7f0b6252dffa">&#9670;&#160;</a></span>clearCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AnalyserLib::clearCache </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Räumt den Cache auf der inter bei dieser Bibliothek erstellt wird </p>

</div>
</div>
<a id="a8c372d8a62e6e383219dfb5b6a48cdf8" name="a8c372d8a62e6e383219dfb5b6a48cdf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c372d8a62e6e383219dfb5b6a48cdf8">&#9670;&#160;</a></span>countTotalWords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AnalyserLib::countTotalWords </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zählt alle Worte in dem übergebenen Text</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>ein Text im dem alle Wörter gezählt werden sollen </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>Die Anzahl aller Worte </dd></dl>

</div>
</div>
<a id="af0778e0ffdc60688b454a332b0038841" name="af0778e0ffdc60688b454a332b0038841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0778e0ffdc60688b454a332b0038841">&#9670;&#160;</a></span>countTotalWordsAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AnalyserLib::countTotalWordsAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Async version </p>

</div>
</div>
<a id="a6907b5b78933ebacb49b4ccd92aec2de" name="a6907b5b78933ebacb49b4ccd92aec2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6907b5b78933ebacb49b4ccd92aec2de">&#9670;&#160;</a></span>createStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stats AnalyserLib::createStatistics </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>wordEndSignes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>sentenceEndSignes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[intern] Erzeugt eine Statsitische erhebung von einem Text. </p>

</div>
</div>
<a id="afeb610691fb21077c29d4f7e13f884e6" name="afeb610691fb21077c29d4f7e13f884e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb610691fb21077c29d4f7e13f884e6">&#9670;&#160;</a></span>createWordDistribution() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aae85ee1355305b0bfd3aeb0173e0ee4a">wordDistribution</a> AnalyserLib::createWordDistribution </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useLowerCase</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zählt die Häufigkeit jedes Wortes im Text. Convertiert intern den Text in eine Liste von Wörtern</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Der Text in dem alle Wörter aufgelistet werden sollen useLowerCase (default = false): wenn useLowerCase gesetzt ist wird der jedes wort in lowercase convertiert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>Gibt eine Unordered map of string int zurück. Key ist das Wort und der Value ist die Häufigkeit wie oft ein Wort vorgekommen ist </dd></dl>

</div>
</div>
<a id="a7f4351ba30ed6a99ee5bd45be7c67014" name="a7f4351ba30ed6a99ee5bd45be7c67014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4351ba30ed6a99ee5bd45be7c67014">&#9670;&#160;</a></span>createWordDistribution() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aae85ee1355305b0bfd3aeb0173e0ee4a">wordDistribution</a> AnalyserLib::createWordDistribution </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stopWords</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>caseSensitive</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zählt die Häufigkeit jedes Wortes im Text. Convertiert intern den Text in eine Liste von Wörtern</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Der Text in dem alle Wörter aufgelistet werden sollen stopWords: Eine Liste von Strings die ignoriert werden sollen und somit nicht mitgezählt werden useLowerCase (default = false): wenn useLowerCase gesetzt ist wird der jedes wort in lowercase convertiert </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>Gibt eine Unordered map of string int zurück. Key ist das Wort und der Value ist die Häufigkeit wie oft ein Wort vorgekommen ist </dd></dl>

</div>
</div>
<a id="a09c88e7303ce7ff98a88cfd781703a7a" name="a09c88e7303ce7ff98a88cfd781703a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c88e7303ce7ff98a88cfd781703a7a">&#9670;&#160;</a></span>createWordDistribution() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aae85ee1355305b0bfd3aeb0173e0ee4a">wordDistribution</a> AnalyserLib::createWordDistribution </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>wordList</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stopWords</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zählt die Häufigkeit jedes Wortes im Text</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">wordList</td><td>Eine Liste von Wörtern die evaluiert werden soll stopWords: Eine Liste von Strings die ignoriert werden sollen und somit nicht mitgezählt werden </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>Gibt eine Unordered map of string int zurück. Key ist das Wort und der Value ist die Häufigkeit wie oft ein Wort vorgekommen ist </dd></dl>

</div>
</div>
<a id="aefa2386a1b2f2933c2953258718a7927" name="aefa2386a1b2f2933c2953258718a7927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa2386a1b2f2933c2953258718a7927">&#9670;&#160;</a></span>createWordDistributionAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aae85ee1355305b0bfd3aeb0173e0ee4a">wordDistribution</a> AnalyserLib::createWordDistributionAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>wordList</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stopWords</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Async version </p>

</div>
</div>
<a id="a2ce7699f603e935dd12574232be6b995" name="a2ce7699f603e935dd12574232be6b995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce7699f603e935dd12574232be6b995">&#9670;&#160;</a></span>createWordDistributionAsyncHelper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#aae85ee1355305b0bfd3aeb0173e0ee4a">wordDistribution</a> AnalyserLib::createWordDistributionAsyncHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>wordList</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a53dbf6b37e0fb454852a6a3f48843b24">constStringList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stopWords</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[intern] helper function weil future und async kein überladenen functionen unterstützt </p>

</div>
</div>
<a id="a2498f93d0680f951204fc0f5519773d8" name="a2498f93d0680f951204fc0f5519773d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2498f93d0680f951204fc0f5519773d8">&#9670;&#160;</a></span>findConnectedWords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9070030da5f341889464c96bb7eeef63">wordPairs</a> AnalyserLib::findConnectedWords </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>minOccurrences</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>range</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Findet herraus welche Worte in einem Satz zusammen auftreten in einer festgelegten Reichweite. Kann verwendet werden für eine "Ko - Okkurrenz Analyse".</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Der Text zum durchsuchen minOccurrences (default=2): Legt fest wie oft eine Paarung auftreten muss damit es in der Ausgabe landet. range (default=2): Legt die reichweite fest in der Paarungen auftreten können. Ein Wert unter 2 ist nicht sinnvoll. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>Gibt eine Unordered Map of <a class="el" href="#a3aa80ba17672b28dab9d21a8e4b80174" title="ein string tuple um 2 Worte zu verknüpfen">strPair</a> int zurück. Der Key besteht aus einem string paar, die beiden Worte die in einem Satz vorgekommen sind. Der Value ist die Anzahl wie oft die Kombination vorgekommen ist. </dd></dl>

</div>
</div>
<a id="acdd26e8ecfd98b0f1053fa3dacb9de68" name="acdd26e8ecfd98b0f1053fa3dacb9de68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd26e8ecfd98b0f1053fa3dacb9de68">&#9670;&#160;</a></span>findConnectedWordsAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a9070030da5f341889464c96bb7eeef63">wordPairs</a> AnalyserLib::findConnectedWordsAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>minOccurrences</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>range</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Async version </p>

</div>
</div>
<a id="a46e4e766540dd4de728753f1e64172ff" name="a46e4e766540dd4de728753f1e64172ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e4e766540dd4de728753f1e64172ff">&#9670;&#160;</a></span>findPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ae305cdd2e542f797a170dcf8d80eb765">searchList</a> AnalyserLib::findPatterns </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::regex &amp;</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suche nach Pattern im Text mit hilfe von RegEx</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>Der Text der nach dem Muster durchsucht werden soll pattern: Gibt das Muster an nach dem gesucht werden soll </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>Gibt einen Vector of <a class="el" href="struct_analyser_lib_1_1_search_result.html">SearchResult</a> zurück. Enthält alle gefundenen string mit ihrere jeweiligen Position im Text. </dd></dl>

</div>
</div>
<a id="a39b9c2eaa61dee96f64d8f3de44e5447" name="a39b9c2eaa61dee96f64d8f3de44e5447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b9c2eaa61dee96f64d8f3de44e5447">&#9670;&#160;</a></span>getStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Stats AnalyserLib::getStats </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hashValue</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[intern] gibt eine gespeicherte Statistic zurück wenn eine passende zum Hash gefunden wird </p>

</div>
</div>
<a id="ae76dba2a04e10748d1d076c77ea0b458" name="ae76dba2a04e10748d1d076c77ea0b458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76dba2a04e10748d1d076c77ea0b458">&#9670;&#160;</a></span>getTextPart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string AnalyserLib::getTextPart </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int &amp;</td>          <td class="paramname"><span class="paramname"><em>start</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>length</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>useLowerCase</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>[intern] Generiert einen sub string aus dem Text mit der übergebenen länge </p>

</div>
</div>
<a id="a7223601e7197362e3be25e1863de1de0" name="a7223601e7197362e3be25e1863de1de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7223601e7197362e3be25e1863de1de0">&#9670;&#160;</a></span>readFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string AnalyserLib::readFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>path</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ad2ef6024965a174775da9bffc1c64b95">cleanupType</a></td>          <td class="paramname"><span class="paramname"><em>type</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ad2ef6024965a174775da9bffc1c64b95a0d85be9676eff76c2752319c04414977">cleanupType::plain</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Läd eine text datei und gibt einen aufgeräumten String zurück</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Der Pfad und die Datei die geladen werden soll type (default=plain): Definiert die Methode mit der der Text aufgeräumt werden soll </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>Gibt den geladenen und aufgeräumten Text zurück. Bei Fehlern einen leeren string. </dd></dl>

</div>
</div>
<a id="ae040414914bc25ce45108ad77d20ee71" name="ae040414914bc25ce45108ad77d20ee71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae040414914bc25ce45108ad77d20ee71">&#9670;&#160;</a></span>saveStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AnalyserLib::saveStats </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>hashValue</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Stats</td>          <td class="paramname"><span class="paramname"><em>s</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[intern] Speichert die Statistiken mit dem Hashwert des textes ab </p>

</div>
</div>
<a id="a40bce1b6d9206ac8ec1b994807cc3fe9" name="a40bce1b6d9206ac8ec1b994807cc3fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40bce1b6d9206ac8ec1b994807cc3fe9">&#9670;&#160;</a></span>scoreToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string AnalyserLib::scoreToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1">ReadabilityScore</a></td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Konvertiert das <a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1">ReadabilityScore</a> enum in einen String</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Das enum was dargestellt werden soll </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>Gibt den passenden String für das <a class="el" href="#ad2d4d9ba367c8ed182a4e3c77b287ed1">ReadabilityScore</a> Enum zurück. </dd></dl>

</div>
</div>
<a id="a7a0a1e324db8026edd0029b62eaaa58d" name="a7a0a1e324db8026edd0029b62eaaa58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0a1e324db8026edd0029b62eaaa58d">&#9670;&#160;</a></span>splitTextIntoStringList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af17700dac156a0cb20b53b7354833bfc">stringList</a> AnalyserLib::splitTextIntoStringList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useLowerCase</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>endSignes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a979a39f6c26519d14a3978c5ad5a636a" name="a979a39f6c26519d14a3978c5ad5a636a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979a39f6c26519d14a3978c5ad5a636a">&#9670;&#160;</a></span>splitTextIntoStringList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af17700dac156a0cb20b53b7354833bfc">stringList</a> AnalyserLib::splitTextIntoStringList </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useLowerCase</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>endingPattern</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="_text_analyser_8h.html#a3f852f86dc1aa3664c66f5b15abd857e">defaultWordEnd</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unterteilt einen Text in kleinere Segmente. Je nachdem was für Zeichen übergeben werde kann man in Worte, Sätze oder was gewünscht unterteilen.</p>
<dl class="params"><dt>Parameter</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>der übergebene Text der unterteilt werden soll useLowerCase (default = false): wenn es gesetzt ist wird der text in lowercase übertragen endingPattern (defult = defaultWordEnd " .,-!?\n"): Jedes Zeichen in dem string sogt dafür das ein Teilstring erzeugt wird. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>RÃ¼ckgabe</dt><dd>Gibt ein vector of String mit den unterteilten strings zurück </dd></dl>

</div>
</div>
<a id="ac9f8b198f445ead40bcaa5897e72c8ae" name="ac9f8b198f445ead40bcaa5897e72c8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f8b198f445ead40bcaa5897e72c8ae">&#9670;&#160;</a></span>splitTextIntoStringListAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#af17700dac156a0cb20b53b7354833bfc">stringList</a> AnalyserLib::splitTextIntoStringListAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>text</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useLowerCase</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>endingPattern</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="_text_analyser_8h.html#a3f852f86dc1aa3664c66f5b15abd857e">defaultWordEnd</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Async version </p>

</div>
</div>
<a id="a1d9ec8b1743fde607707329552284a71" name="a1d9ec8b1743fde607707329552284a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9ec8b1743fde607707329552284a71">&#9670;&#160;</a></span>toLowerCase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AnalyserLib::toLowerCase </td>
          <td>(</td>
          <td class="paramtype">string &amp;</td>          <td class="paramname"><span class="paramname"><em>word</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>[intern] Eine Helper Funktion um ein Wort in LowerCase zu convertieren </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespace_analyser_lib.html">AnalyserLib</a></li>
    <li class="footer">Erzeugt von <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
